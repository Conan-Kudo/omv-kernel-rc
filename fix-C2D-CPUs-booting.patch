diff -up linux-4.18/kernel/time/clocksource.c.0330~ linux-4.18/kernel/time/clocksource.c
--- linux-4.18/kernel/time/clocksource.c.0330~	2018-09-03 15:38:54.281724119 +0200
+++ linux-4.18/kernel/time/clocksource.c	2018-09-03 15:40:56.145967466 +0200
@@ -112,13 +112,27 @@ static int finished_booting;
 static u64 suspend_start;
 
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG
-static void clocksource_watchdog_work(struct work_struct *work);
+static void clocksource_watchdog_work(struct kthread_work *work);
 static void clocksource_select(void);
 
 static LIST_HEAD(watchdog_list);
 static struct clocksource *watchdog;
 static struct timer_list watchdog_timer;
-static DECLARE_WORK(watchdog_work, clocksource_watchdog_work);
+/*
+ * We must use a kthread_worker here, because:
+ *
+ *   clocksource_watchdog_work()
+ *     clocksource_select()
+ *       __clocksource_select()
+ *         timekeeping_notify()
+ *           stop_machine()
+ *
+ * cannot be called from a reqular workqueue, because of deadlocks between
+ * workqueue and stopmachine.
+ */
+static struct kthread_worker *watchdog_worker;
+static DEFINE_KTHREAD_WORK(watchdog_work, clocksource_watchdog_work);
+
 static DEFINE_SPINLOCK(watchdog_lock);
 static int watchdog_running;
 static atomic_t watchdog_reset_pending;
@@ -158,7 +172,7 @@ static void __clocksource_unstable(struc
 
 	/* kick clocksource_watchdog_work() */
 	if (finished_booting)
-		schedule_work(&watchdog_work);
+		kthread_queue_work(watchdog_worker, &watchdog_work);
 }
 
 /**
@@ -199,7 +213,7 @@ static void clocksource_watchdog(struct
 		/* Clocksource already marked unstable? */
 		if (cs->flags & CLOCK_SOURCE_UNSTABLE) {
 			if (finished_booting)
-				schedule_work(&watchdog_work);
+				kthread_queue_work(watchdog_worker, &watchdog_work);
 			continue;
 		}
 
@@ -269,7 +283,7 @@ static void clocksource_watchdog(struct
 			 */
 			if (cs != curr_clocksource) {
 				cs->flags |= CLOCK_SOURCE_RESELECT;
-				schedule_work(&watchdog_work);
+				kthread_queue_work(watchdog_worker, &watchdog_work);
 			} else {
 				tick_clock_notify();
 			}
@@ -418,7 +432,7 @@ static int __clocksource_watchdog_work(v
 	return select;
 }
 
-static void clocksource_watchdog_work(struct work_struct *work)
+static void clocksource_watchdog_work(struct kthread_work *work)
 {
 	mutex_lock(&clocksource_mutex);
 	if (__clocksource_watchdog_work())
@@ -806,6 +820,7 @@ static int __init clocksource_done_booti
 {
 	mutex_lock(&clocksource_mutex);
 	curr_clocksource = clocksource_default_clock();
+	watchdog_worker = kthread_create_worker(0, "cs-watchdog");
 	finished_booting = 1;
 	/*
 	 * Run the watchdog first to eliminate unstable clock sources
